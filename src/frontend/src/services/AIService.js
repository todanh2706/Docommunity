import axiosInstance from '../hooks/useApi';

const BACKEND_ROOT = '/ai';
const USE_MOCK_DATA = false;

// Timeout riêng cho AI requests (30 giây - AI cần thời gian xử lý lâu hơn)
const AI_TIMEOUT = 30000;

const mockDelay = (ms = 1000) => new Promise(resolve => setTimeout(resolve, ms));


export const getAiChat = async (message) => {
    if (USE_MOCK_DATA) {
        await mockDelay();
        return {
            reply: `[MOCK] This is a simulated AI response for: "${message}".\n\nI can help you with writing, coding, or summarizing documents.`
        };
    }
    try {
        const response = await axiosInstance.post(
            `${BACKEND_ROOT}/chat`, 
            { 'message': message },
            { timeout: AI_TIMEOUT }
        );
        return response.data;
    } catch (error) {
        console.error('Error fetching documents:', error);
        throw error;
    }
}

export const generateContent = async (type, prompt) => {
    if (USE_MOCK_DATA) {
        await mockDelay(2000);
        return {
            content: `## [MOCK] Generated Content (${type})\n\n> Prompt: *${prompt}*\n\nHere is the content generated by the AI simulation:\n\n1. **Introduction**: This is a placeholder text to demonstrate the UI.\n2. **Details**: You can edit this text just like any other markdown content.\n3. **Conclusion**: The integration works perfectly!\n\n\`\`\`javascript\nconsole.log("Hello Mock World!");\n\`\`\``
        };
    }
    try {
        const response = await axiosInstance.post(
            `${BACKEND_ROOT}/generate`, 
            { type, prompt },
            { timeout: AI_TIMEOUT }
        );
        return response.data;
    } catch (error) {
        console.error('Error generating content:', error);
        throw error;
    }
}

export const refineContent = async (docId, text, instruction) => {
    if (USE_MOCK_DATA) {
        await mockDelay(2000);
        return {
            content: `[MOCK REFINED]\n\n${text}\n\n--- Refined based on: "${instruction}" ---\n\nThis is the refined version of the text. The AI has improved clarity and grammar.`
        };
    }
    try {
        // Use the document-specific endpoint if docId is provided
        const url = docId ? `/documents/${docId}/refine` : `${BACKEND_ROOT}/refine`;

        // Backend expects different payloads for DocumentController vs AIController (if implemented)
        let payload;
        if (docId) {
            // DocumentController uses RefineDocumentRequest: { action, content }
            payload = {
                action: instruction,
                content: text
            };
        } else {
            // AIController (generic) would use RefineTextRequest: { instruction, text }
            payload = {
                instruction: instruction,
                text: text
            };
        }

        const response = await axiosInstance.post(url, payload, { timeout: AI_TIMEOUT });

        // Backend returns ResponseDTO { data: { refineContent: "..." } }
        const result = response.data.data || response.data;

        // Normalize: Helper for consistent UI usage (EditorPage expects 'content')
        if (result && result.refineContent) {
            result.content = result.refineContent;
        }

        return result;
    } catch (error) {
        console.error('Error refining content:', error);
        throw error;
    }
}

export const suggestTags = async (content) => {
    if (USE_MOCK_DATA) {
        await mockDelay(1500);
        return {
            tags: ['ai-suggested', 'mock-tag', 'auto-generated']
        };
    }
    try {
        const response = await axiosInstance.post(
            `${BACKEND_ROOT}/tags`, 
            { content },
            { timeout: AI_TIMEOUT }
        );
        return response.data;
    } catch (error) {
        console.error('Error suggesting tags:', error);
        throw error;
    }
}

// Writing suggestion (autocomplete) - supports request cancellation via AbortController
export const getWritingSuggestion = async (content, cursorText, maxTokens = 50, options = {}) => {
    const { signal } = options;

    if (USE_MOCK_DATA) {
        await mockDelay(300);
        return { suggestion: " tiếp tục viết nội dung ở đây..." };
    }
    try {
        const response = await axiosInstance.post(`${BACKEND_ROOT}/autocomplete`, {
            content,
            cursorText,
            maxTokens
        }, { signal });
        return response.data;
    } catch (error) {
        // Don't log aborted requests as errors - they're intentional
        if (error.name === 'CanceledError' || error.name === 'AbortError') {
            return { suggestion: '' };
        }
        console.error('Error getting suggestion:', error);
        // Return empty suggestion on error to avoid breaking the UI
        return { suggestion: '' };
    }
}
